generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  role         String   @default("ADMIN") // ADMIN | CASHIER
  createdAt    DateTime @default(now())

  sessions Session[]
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PaymentMethod {
  id      String  @id @default(cuid())
  name    String  @unique
  enabled Boolean @default(true)
  isCash  Boolean @default(false)

  payments Payment[]
}

model Denomination {
  id      String  @id @default(cuid())
  type    String // BILL | COIN
  value   Int
  enabled Boolean @default(true)

  cashLines CashLine[]

  @@unique([type, value])
}

model Ingredient {
  id        String   @id @default(cuid())
  name      String   @unique
  unit      String   @default("unit")
  stock     Float    @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  recipeItems RecipeItem[]

  // =========================
  // NUEVO: “Producto” contable
  // (precio del paquete y rendimiento)
  // =========================
  product IngredientProduct?

  // =========================
  // NUEVO: Lotes FIFO (costos por compra)
  // =========================
  batches IngredientBatch[]
}

//
// NUEVO: Configuración contable por ingrediente (pestaña productos)
// packPrice: precio total del paquete (COP)
// packQty: cantidad que trae / porciones (misma unidad del ingrediente)
// unitCost implícito = packPrice / packQty
//
model IngredientProduct {
  id           String @id @default(cuid())
  ingredientId String @unique

  packPrice Int
  packQty   Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ingredient Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
}

//
// NUEVO: Lote de compra para FIFO
// qtyRemaining: cuánto queda de ese lote
// unitCost: costo unitario en COP por unidad del ingrediente
//
model IngredientBatch {
  id           String   @id @default(cuid())
  ingredientId String
  qtyInitial   Float
  qtyRemaining Float
  unitCost     Float
  createdAt    DateTime @default(now())

  ingredient Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  @@index([ingredientId, createdAt])
}

model Dish {
  id        String       @id @default(cuid())
  name      String       @unique
  price     Int
  category  DishCategory @default(MAIN)
  enabled   Boolean      @default(true)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  recipe    RecipeItem[]
  saleItems SaleItem[]
}

model RecipeItem {
  id           String @id @default(cuid())
  dishId       String
  ingredientId String
  qty          Float

  dish       Dish       @relation(fields: [dishId], references: [id], onDelete: Cascade)
  ingredient Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  @@unique([dishId, ingredientId])
}

model Counter {
  key   String @id
  value Int
}

model Sale {
  id        String   @id @default(cuid())
  ticketNo  Int
  total     Int
  createdAt DateTime @default(now())

  sessionId    String?
  session      CashSession? @relation(fields: [sessionId], references: [id])
  isManagement Boolean      @default(false)

  items   SaleItem[]
  payment Payment?
}

model SaleItem {
  id     String @id @default(cuid())
  saleId String
  dishId String
  qty    Int
  price  Int

  sale Sale @relation(fields: [saleId], references: [id], onDelete: Cascade)
  dish Dish @relation(fields: [dishId], references: [id])
}

model Payment {
  id       String @id @default(cuid())
  saleId   String @unique
  methodId String
  amount   Int

  cashReceived Int?
  changeGiven  Int?

  sale   Sale          @relation(fields: [saleId], references: [id], onDelete: Cascade)
  method PaymentMethod @relation(fields: [methodId], references: [id])

  cashLines CashLine[]
}

model CashLine {
  id             String @id @default(cuid())
  paymentId      String
  denominationId String
  qty            Int

  payment      Payment      @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  denomination Denomination @relation(fields: [denominationId], references: [id])
}

model CashSession {
  id       String    @id @default(cuid())
  openedAt DateTime  @default(now())
  closedAt DateTime?
  status   String    @default("OPEN") // OPEN | CLOSED
  baseCash Int       @default(0)

  expenses CashExpense[]
  sales    Sale[]
}

enum DishCategory {
  STARTER // Entrada
  MAIN // Plato Fuerte
  DRINK // Bebida
}

model CashExpense {
  id          String   @id @default(cuid())
  sessionId   String
  amount      Int
  description String
  createdAt   DateTime @default(now())

  session CashSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}
